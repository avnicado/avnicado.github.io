<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trust-Weighted Link Analysis Demo</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f5f5f5;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    h1 {
      color: #2c3e50;
      margin-bottom: 20px;
      font-size: 2.5em;
    }
    
    h2 {
      color: #34495e;
      margin-top: 30px;
      margin-bottom: 15px;
      font-size: 1.8em;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
    }
    
    h3 {
      color: #555;
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 1.3em;
    }
    
    .intro {
      background: #ecf0f1;
      padding: 20px;
      border-radius: 5px;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    
    .warning {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 20px 0;
    }
    
    .controls {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 5px;
      margin: 20px 0;
    }
    
    .control-group {
      margin: 15px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .control-group label {
      min-width: 200px;
      font-weight: 600;
    }
    
    .control-group input[type="range"] {
      flex: 1;
      max-width: 300px;
    }
    
    .control-group .value {
      min-width: 60px;
      text-align: right;
      font-family: monospace;
    }
    
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      font-weight: 600;
      margin: 10px 5px;
      transition: background 0.3s;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .chart-container {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 15px;
    }
    
    canvas {
      max-width: 100%;
      height: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 0.9em;
    }
    
    th {
      background: #34495e;
      color: white;
      padding: 12px;
      text-align: left;
      font-weight: 600;
    }
    
    td {
      padding: 10px 12px;
      border-bottom: 1px solid #ddd;
    }
    
    tr:nth-child(even) {
      background: #f8f9fa;
    }
    
    tr:hover {
      background: #e9ecef;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .stat-card {
      background: #3498db;
      color: white;
      padding: 20px;
      border-radius: 5px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      margin: 10px 0;
    }
    
    .stat-label {
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    ul {
      margin: 10px 0 10px 30px;
    }
    
    li {
      margin: 5px 0;
    }
    
    code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
    
    .highlight {
      background: #d4edda;
      padding: 2px 4px;
      border-radius: 3px;
    }
    
    .lowlight {
      background: #f8d7da;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Trust-Weighted Link Analysis Demo</h1>
    
    <div class="intro">
      <p><strong>The Core Idea:</strong> In rating systems, not all raters are equally reliable. Some users consistently identify high-quality content, while others have poor judgment or act maliciously. This demo shows how we can iteratively learn user reliability weights based on rating agreement, then use those weights to compute better content scores.</p>
      
      <p style="margin-top: 10px;"><strong>How It Works:</strong> We start by treating all users equally. Then, in each iteration, we compute content quality scores weighted by user reliability, and update user reliabilities based on how well their ratings align with the estimated content quality. Users who consistently rate high-quality content highly gain influence, while those with poor or adversarial rating patterns lose influence.</p>
    </div>
    
    <div class="warning">
      <strong>‚ö†Ô∏è Important Disclaimer:</strong> This is an <strong>educational mockup</strong> to explain a concept, not a production system. The "quality" scores are based on consistency within the simulated data, not universal truth. Real-world systems face complex challenges including cold-start problems, echo chambers, adversarial attacks, and value subjectivity. This demo uses synthetic data to illustrate mechanics, not to make normative judgments about quality.
    </div>
    
    <h2>Interactive Controls</h2>
    <div class="controls">
      <h3>Simulation Parameters</h3>
      <div class="control-group">
        <label for="numUsers">Number of Users:</label>
        <input type="range" id="numUsers" min="15" max="50" value="25" step="1">
        <span class="value" id="numUsersValue">25</span>
      </div>
      <div class="control-group">
        <label for="numContent">Number of Content Items:</label>
        <input type="range" id="numContent" min="20" max="80" value="40" step="5">
        <span class="value" id="numContentValue">40</span>
      </div>
      <div class="control-group">
        <label for="ratingDensity">Rating Density (%):</label>
        <input type="range" id="ratingDensity" min="20" max="80" value="40" step="5">
        <span class="value" id="ratingDensityValue">40%</span>
      </div>
      <div class="control-group">
        <label for="noiseLevel">Noise Level:</label>
        <input type="range" id="noiseLevel" min="0.05" max="0.3" value="0.15" step="0.01">
        <span class="value" id="noiseLevelValue">0.15</span>
      </div>
      
      <h3>Algorithm Parameters</h3>
      <div class="control-group">
        <label for="damping">Damping Factor (Œ≥):</label>
        <input type="range" id="damping" min="0.1" max="0.9" value="0.3" step="0.05">
        <span class="value" id="dampingValue">0.3</span>
      </div>
      <div class="control-group">
        <label for="alpha">Alignment Exponent (Œ±):</label>
        <input type="range" id="alpha" min="1" max="4" value="2" step="0.5">
        <span class="value" id="alphaValue">2</span>
      </div>
      <div class="control-group">
        <label for="rMin">Min Reliability (r_min):</label>
        <input type="range" id="rMin" min="0.01" max="0.2" value="0.05" step="0.01">
        <span class="value" id="rMinValue">0.05</span>
      </div>
      <div class="control-group">
        <label for="rMax">Max Reliability (r_max):</label>
        <input type="range" id="rMax" min="1.5" max="3" value="2" step="0.1">
        <span class="value" id="rMaxValue">2.0</span>
      </div>
      <div class="control-group">
        <label for="maxIterations">Max Iterations:</label>
        <input type="range" id="maxIterations" min="5" max="50" value="20" step="1">
        <span class="value" id="maxIterationsValue">20</span>
      </div>
      
      <button onclick="runSimulation()">üîÑ Run Simulation</button>
      <button onclick="resetToDefaults()">‚Ü∫ Reset to Defaults</button>
    </div>
    
    <div id="results" style="display: none;">
      <h2>Results</h2>
      
      <div class="stats" id="statsContainer"></div>
      
      <h3>Content Rankings Comparison</h3>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div>
          <h4 style="text-align: center; color: #e74c3c;">‚ùå Unweighted (Naive Average)</h4>
          <table id="unweightedTable"></table>
        </div>
        <div>
          <h4 style="text-align: center; color: #27ae60;">‚úÖ Weighted (Trust-Based)</h4>
          <table id="weightedTable"></table>
        </div>
      </div>
      
      <h3>User Reliabilities</h3>
      <table id="userTable"></table>
      
      <h3>Visualizations</h3>
      <div class="charts-grid">
        <div class="chart-container">
          <h4>Reliability Distribution</h4>
          <canvas id="reliabilityChart" width="500" height="300"></canvas>
        </div>
        <div class="chart-container">
          <h4>User Reliability vs Rating Error</h4>
          <canvas id="errorChart" width="500" height="300"></canvas>
        </div>
      </div>
      
      <div class="chart-container">
        <h4>Convergence Over Iterations</h4>
        <canvas id="convergenceChart" width="1000" height="300"></canvas>
      </div>
    </div>
    
    <h2>How It Works: Algorithm Explanation</h2>
    <div>
      <h3>1. Initialization</h3>
      <p>All users start with equal reliability <code>r_i = 1.0</code>. Content has no initial scores.</p>
      
      <h3>2. Iterative Updates</h3>
      <p><strong>Step A: Compute Content Scores</strong></p>
      <p>For each content item j, calculate a weighted average of ratings:</p>
      <p style="margin-left: 30px;"><code>q_j = (Œ£ r_i √ó rating_ij) / (Œ£ r_i)</code></p>
      <p>where the sum is over all users i who rated content j.</p>
      
      <p style="margin-top: 15px;"><strong>Step B: Update User Reliabilities</strong></p>
      <p>For each user i, calculate alignment with content scores:</p>
      <p style="margin-left: 30px;"><code>A_i = average of (1 - |rating_ij - q_j|)</code></p>
      <p>Then update reliability with damping:</p>
      <p style="margin-left: 30px;"><code>r_i = (1-Œ≥)√ór_i + Œ≥√ó[r_min + (r_max-r_min)√óA_i^Œ±]</code></p>
      
      <h3>3. Convergence</h3>
      <p>Repeat until changes in scores and reliabilities are small, or max iterations reached.</p>
    </div>
    
    <h2>User Types in Simulation</h2>
    <ul>
      <li><strong class="highlight">Discerning Users (25%):</strong> Rate accurately with minimal noise. These users should gain high reliability.</li>
      <li><strong>Average Users (30%):</strong> Rate reasonably well with moderate noise.</li>
      <li><strong class="lowlight">Contrarian Users (15%):</strong> Systematically rate good content low and bad content high. Should lose reliability.</li>
      <li><strong class="lowlight">Random Users (20%):</strong> Rate without regard to quality. Should lose reliability.</li>
      <li><strong class="lowlight">Colluding Users (10%):</strong> Artificially inflate ratings for specific content. Should lose reliability.</li>
    </ul>
    
    <h2>Limitations & Safeguards</h2>
    <div class="warning">
      <h3>Known Limitations:</h3>
      <ul>
        <li><strong>Cold Start:</strong> New users and content have insufficient data. Priors (starting values) and minimum rating thresholds help mitigate this.</li>
        <li><strong>Echo Chambers:</strong> The system can amplify dominant opinions. Diversity constraints and reliability caps (r_max) help limit this.</li>
        <li><strong>Adversarial Attacks:</strong> Coordinated voting can still manipulate scores, especially with low diversity. Real systems need anomaly detection, time-windowing, and rate limits.</li>
        <li><strong>Value Subjectivity:</strong> "Quality" is contextual and cultural. This model optimizes for internal consistency, not universal truth.</li>
        <li><strong>Feedback Loops:</strong> Reliability affects scores, which affect reliability. Damping and bounded reliability prevent runaway effects.</li>
      </ul>
      
      <h3>Mitigations Used:</h3>
      <ul>
        <li>Bounded reliability (<code>r_min</code> to <code>r_max</code>) prevents extreme weighting</li>
        <li>Damping factor <code>Œ≥</code> slows updates and improves stability</li>
        <li>Exponent <code>Œ±</code> makes the reliability function non-linear, rewarding consistency</li>
        <li>Small epsilon prevents division by zero</li>
      </ul>
    </div>
    
    <h2>How to Run This Demo</h2>
    <ol>
      <li>Simply open this HTML file in any modern web browser (Chrome, Firefox, Safari, Edge)</li>
      <li>No server, build tools, or external dependencies required</li>
      <li>Adjust the parameters using the sliders above</li>
      <li>Click "Run Simulation" to generate new data and see results</li>
      <li>Observe how different user types gain or lose reliability</li>
      <li>Compare unweighted vs weighted content rankings</li>
    </ol>
    
    <h2>Alternative Approaches (Brief Overview)</h2>
    <ul>
      <li><strong>EigenTrust / PageRank:</strong> Use eigenvector centrality on the trust graph; more resistant to collusion but computationally heavier.</li>
      <li><strong>HITS Algorithm:</strong> Treat users as "authorities" and content as "hubs" in a bipartite graph; similar iterative approach with different update rules.</li>
      <li><strong>Bayesian Hierarchical Models:</strong> Model user bias and noise as distributions; provides uncertainty estimates but requires MCMC or variational inference.</li>
      <li><strong>Matrix Factorization:</strong> Factor user-content rating matrix to discover latent quality dimensions; good for prediction but less interpretable.</li>
    </ul>
    
    <div style="margin-top: 40px; padding: 20px; background: #ecf0f1; border-radius: 5px; text-align: center;">
      <p><strong>Remember:</strong> This is a demonstration of a concept, not a production-ready system. Real-world implementations require extensive testing, safeguards, and ethical considerations.</p>
    </div>
  </div>
  
  <script>
    // ==================== DATA STRUCTURES ====================
    let users = [];
    let content = [];
    let ratings = [];
    let params = {};
    let results = {};
    
    // ==================== INITIALIZATION ====================
    function initializeParams() {
      params = {
        numUsers: parseInt(document.getElementById('numUsers').value),
        numContent: parseInt(document.getElementById('numContent').value),
        ratingDensity: parseInt(document.getElementById('ratingDensity').value) / 100,
        noiseLevel: parseFloat(document.getElementById('noiseLevel').value),
        damping: parseFloat(document.getElementById('damping').value),
        alpha: parseFloat(document.getElementById('alpha').value),
        rMin: parseFloat(document.getElementById('rMin').value),
        rMax: parseFloat(document.getElementById('rMax').value),
        maxIterations: parseInt(document.getElementById('maxIterations').value),
        epsilon: 1e-6
      };
    }
    
    function updateDisplayedValues() {
      document.getElementById('numUsersValue').textContent = document.getElementById('numUsers').value;
      document.getElementById('numContentValue').textContent = document.getElementById('numContent').value;
      document.getElementById('ratingDensityValue').textContent = document.getElementById('ratingDensity').value + '%';
      document.getElementById('noiseLevelValue').textContent = document.getElementById('noiseLevel').value;
      document.getElementById('dampingValue').textContent = document.getElementById('damping').value;
      document.getElementById('alphaValue').textContent = document.getElementById('alpha').value;
      document.getElementById('rMinValue').textContent = document.getElementById('rMin').value;
      document.getElementById('rMaxValue').textContent = document.getElementById('rMax').value;
      document.getElementById('maxIterationsValue').textContent = document.getElementById('maxIterations').value;
    }
    
    function resetToDefaults() {
      document.getElementById('numUsers').value = 25;
      document.getElementById('numContent').value = 40;
      document.getElementById('ratingDensity').value = 40;
      document.getElementById('noiseLevel').value = 0.15;
      document.getElementById('damping').value = 0.3;
      document.getElementById('alpha').value = 2;
      document.getElementById('rMin').value = 0.05;
      document.getElementById('rMax').value = 2;
      document.getElementById('maxIterations').value = 20;
      updateDisplayedValues();
    }
    
    // Add event listeners for real-time value updates
    document.querySelectorAll('input[type="range"]').forEach(input => {
      input.addEventListener('input', updateDisplayedValues);
    });
    
    // ==================== DATA GENERATION ====================
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    
    function randomNormal(mean = 0, stddev = 1) {
      // Box-Muller transform
      let u1 = Math.random();
      let u2 = Math.random();
      let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      return mean + z0 * stddev;
    }
    
    function generateUsers() {
      users = [];
      const types = [
        { name: 'discerning', count: Math.floor(params.numUsers * 0.25), noise: 0.05 },
        { name: 'average', count: Math.floor(params.numUsers * 0.30), noise: 0.15 },
        { name: 'contrarian', count: Math.floor(params.numUsers * 0.15), noise: 0.15 },
        { name: 'random', count: Math.floor(params.numUsers * 0.20), noise: 0.5 },
        { name: 'colluding', count: Math.floor(params.numUsers * 0.10), noise: 0.05 }
      ];
      
      // Adjust last type to match exact count
      const totalAssigned = types.reduce((sum, t) => sum + t.count, 0);
      types[types.length - 1].count += params.numUsers - totalAssigned;
      
      let userId = 0;
      types.forEach(type => {
        for (let i = 0; i < type.count; i++) {
          users.push({
            id: userId++,
            type: type.name,
            noise: type.noise * params.noiseLevel,
            reliability: 1.0,
            initialReliability: 1.0
          });
        }
      });
      
      // Shuffle users
      for (let i = users.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [users[i], users[j]] = [users[j], users[i]];
      }
      
      // Reassign IDs after shuffle
      users.forEach((user, idx) => user.id = idx);
    }
    
    function generateContent() {
      content = [];
      for (let i = 0; i < params.numContent; i++) {
        content.push({
          id: i,
          trueQuality: Math.random(), // Ground truth in [0, 1]
          score: 0,
          unweightedScore: 0,
          numRatings: 0
        });
      }
    }
    
    function generateRatings() {
      ratings = [];
      const colludingTargets = new Set();
      
      // Select 10-20% of content as targets for colluders
      const numTargets = Math.floor(params.numContent * 0.15);
      while (colludingTargets.size < numTargets) {
        colludingTargets.add(Math.floor(Math.random() * params.numContent));
      }
      
      users.forEach(user => {
        content.forEach(item => {
          if (Math.random() < params.ratingDensity) {
            let rating;
            const trueQ = item.trueQuality;
            
            switch (user.type) {
              case 'discerning':
                rating = clamp(trueQ + randomNormal(0, user.noise), 0, 1);
                break;
              case 'average':
                rating = clamp(trueQ + randomNormal(0, user.noise), 0, 1);
                break;
              case 'contrarian':
                rating = clamp((1 - trueQ) + randomNormal(0, user.noise), 0, 1);
                break;
              case 'random':
                rating = Math.random();
                break;
              case 'colluding':
                if (colludingTargets.has(item.id)) {
                  // Inflate rating regardless of true quality
                  rating = clamp(0.8 + randomNormal(0, user.noise), 0, 1);
                } else {
                  // Rate normally otherwise
                  rating = clamp(trueQ + randomNormal(0, user.noise * 2), 0, 1);
                }
                break;
              default:
                rating = Math.random();
            }
            
            ratings.push({
              userId: user.id,
              contentId: item.id,
              rating: rating
            });
          }
        });
      });
    }
    
    // ==================== ALGORITHM ====================
    function computeContentScores() {
      content.forEach(item => {
        let weightedSum = 0;
        let weightSum = 0;
        let unweightedSum = 0;
        let count = 0;
        
        ratings.forEach(r => {
          if (r.contentId === item.id) {
            const user = users[r.userId];
            weightedSum += user.reliability * r.rating;
            weightSum += user.reliability;
            unweightedSum += r.rating;
            count++;
          }
        });
        
        item.score = count > 0 ? weightedSum / (weightSum + params.epsilon) : 0.5;
        item.unweightedScore = count > 0 ? unweightedSum / count : 0.5;
        item.numRatings = count;
      });
    }
    
    function updateUserReliabilities() {
      users.forEach(user => {
        let alignmentSum = 0;
        let count = 0;
        
        ratings.forEach(r => {
          if (r.userId === user.id) {
            const item = content[r.contentId];
            if (item.numRatings > 0) {
              const error = Math.abs(r.rating - item.score);
              const alignment = 1 - error;
              alignmentSum += alignment;
              count++;
            }
          }
        });
        
        if (count > 0) {
          const avgAlignment = alignmentSum / count;
          // Map alignment to [rMin, rMax] with exponent
          const newReliability = params.rMin + 
            (params.rMax - params.rMin) * Math.pow(avgAlignment, params.alpha);
          
          // Apply damping
          user.reliability = (1 - params.damping) * user.reliability + 
                            params.damping * newReliability;
        }
      });
    }
    
    function runAlgorithm() {
      const history = {
        deltaQ: [],
        deltaR: [],
        meanReliability: []
      };
      
      // Initialize
      users.forEach(user => user.reliability = 1.0);
      
      for (let iter = 0; iter < params.maxIterations; iter++) {
        // Store previous values
        const prevScores = content.map(c => c.score);
        const prevReliabilities = users.map(u => u.reliability);
        
        // Update
        computeContentScores();
        updateUserReliabilities();
        
        // Compute deltas
        let deltaQ = 0;
        content.forEach((item, i) => {
          deltaQ += Math.abs(item.score - prevScores[i]);
        });
        deltaQ /= content.length;
        
        let deltaR = 0;
        users.forEach((user, i) => {
          deltaR += Math.abs(user.reliability - prevReliabilities[i]);
        });
        deltaR /= users.length;
        
        const meanR = users.reduce((sum, u) => sum + u.reliability, 0) / users.length;
        
        history.deltaQ.push(deltaQ);
        history.deltaR.push(deltaR);
        history.meanReliability.push(meanR);
        
        // Check convergence
        if (iter > 3 && deltaQ < 0.001 && deltaR < 0.001) {
          break;
        }
      }
      
      return history;
    }
    
    // ==================== VISUALIZATION ====================
    function drawBarChart(canvas, data, options = {}) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 40;
      const chartWidth = width - 2 * padding;
      const chartHeight = height - 2 * padding;
      
      ctx.clearRect(0, 0, width, height);
      
      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      
      if (data.length === 0) return;
      
      const maxValue = options.maxValue || Math.max(...data.map(d => d.value));
      const minValue = options.minValue || 0;
      const range = maxValue - minValue;
      
      const barWidth = chartWidth / data.length - 2;
      
      // Draw bars
      data.forEach((item, i) => {
        const barHeight = ((item.value - minValue) / range) * chartHeight;
        const x = padding + i * (chartWidth / data.length);
        const y = height - padding - barHeight;
        
        ctx.fillStyle = item.color || '#3498db';
        ctx.fillRect(x, y, barWidth, barHeight);
      });
      
      // Draw axes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Labels
      ctx.fillStyle = '#333';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(options.xLabel || '', width / 2, height - 5);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(options.yLabel || '', 0, 0);
      ctx.restore();
      
      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = height - padding - (chartHeight * i / 5);
        ctx.fillText(value.toFixed(2), padding - 5, y);
        
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      }
    }
    
    function drawScatterPlot(canvas, data, options = {}) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 50;
      const chartWidth = width - 2 * padding;
      const chartHeight = height - 2 * padding;
      
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      
      if (data.length === 0) return;
      
      const xValues = data.map(d => d.x);
      const yValues = data.map(d => d.y);
      const minX = options.minX ?? Math.min(...xValues);
      const maxX = options.maxX ?? Math.max(...xValues);
      const minY = options.minY ?? Math.min(...yValues);
      const maxY = options.maxY ?? Math.max(...yValues);
      const rangeX = maxX - minX || 1;
      const rangeY = maxY - minY || 1;
      
      // Draw grid
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const x = padding + (chartWidth * i / 5);
        const y = height - padding - (chartHeight * i / 5);
        
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Draw points
      data.forEach(point => {
        const x = padding + ((point.x - minX) / rangeX) * chartWidth;
        const y = height - padding - ((point.y - minY) / rangeY) * chartHeight;
        
        ctx.fillStyle = point.color || '#3498db';
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
      
      // Labels
      ctx.fillStyle = '#333';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(options.xLabel || '', width / 2, height - 10);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(options.yLabel || '', 0, 0);
      ctx.restore();
      
      // Axis ticks
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let i = 0; i <= 5; i++) {
        const value = minX + (rangeX * i / 5);
        const x = padding + (chartWidth * i / 5);
        ctx.fillText(value.toFixed(2), x, height - padding + 5);
      }
      
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 5; i++) {
        const value = minY + (rangeY * i / 5);
        const y = height - padding - (chartHeight * i / 5);
        ctx.fillText(value.toFixed(2), padding - 5, y);
      }
    }
    
    function drawLineChart(canvas, datasets, options = {}) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 50;
      const chartWidth = width - 2 * padding;
      const chartHeight = height - 2 * padding;
      
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      
      if (datasets.length === 0 || datasets[0].data.length === 0) return;
      
      const allValues = datasets.flatMap(ds => ds.data);
      const maxValue = options.maxValue ?? Math.max(...allValues);
      const minValue = options.minValue ?? Math.min(...allValues);
      const range = maxValue - minValue || 1;
      const numPoints = datasets[0].data.length;
      
      // Draw grid
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = height - padding - (chartHeight * i / 5);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Draw lines
      datasets.forEach(dataset => {
        ctx.strokeStyle = dataset.color || '#3498db';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        dataset.data.forEach((value, i) => {
          const x = padding + (chartWidth * i / (numPoints - 1));
          const y = height - padding - ((value - minValue) / range) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        
        ctx.stroke();
        
        // Draw points
        dataset.data.forEach((value, i) => {
          const x = padding + (chartWidth * i / (numPoints - 1));
          const y = height - padding - ((value - minValue) / range) * chartHeight;
          
          ctx.fillStyle = dataset.color || '#3498db';
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      });
      
      // Labels
      ctx.fillStyle = '#333';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(options.xLabel || '', width / 2, height - 10);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(options.yLabel || '', 0, 0);
      ctx.restore();
      
      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = height - padding - (chartHeight * i / 5);
        ctx.fillText(value.toFixed(3), padding - 5, y);
      }
      
      // Legend
      const legendX = width - padding - 150;
      const legendY = padding + 20;
      datasets.forEach((dataset, i) => {
        const y = legendY + i * 20;
        
        ctx.fillStyle = dataset.color;
        ctx.fillRect(legendX, y - 5, 15, 10);
        
        ctx.fillStyle = '#333';
        ctx.textAlign = 'left';
        ctx.fillText(dataset.label, legendX + 20, y);
      });
    }
    
    // ==================== DISPLAY RESULTS ====================
    function displayResults(history) {
      document.getElementById('results').style.display = 'block';
      
      // Statistics
      const stats = [
        { label: 'Total Users', value: users.length },
        { label: 'Total Content', value: content.length },
        { label: 'Total Ratings', value: ratings.length },
        { label: 'Iterations', value: history.deltaQ.length }
      ];
      
      const statsHtml = stats.map(s => `
        <div class="stat-card">
          <div class="stat-label">${s.label}</div>
          <div class="stat-value">${s.value}</div>
        </div>
      `).join('');
      document.getElementById('statsContainer').innerHTML = statsHtml;
      
      // Top content tables
      const sortedByWeighted = [...content].sort((a, b) => b.score - a.score);
      const sortedByUnweighted = [...content].sort((a, b) => b.unweightedScore - a.unweightedScore);
      
      const makeTableRows = (items, useWeighted) => {
        return items.slice(0, 15).map((item, idx) => {
          const scoreVal = useWeighted ? item.score : item.unweightedScore;
          const qualityDiff = Math.abs(scoreVal - item.trueQuality);
          const accuracyClass = qualityDiff < 0.15 ? 'highlight' : (qualityDiff > 0.3 ? 'lowlight' : '');
          
          return `
            <tr>
              <td>${idx + 1}</td>
              <td>Content ${item.id}</td>
              <td>${item.trueQuality.toFixed(3)}</td>
              <td class="${accuracyClass}">${scoreVal.toFixed(3)}</td>
              <td>${qualityDiff.toFixed(3)}</td>
              <td>${item.numRatings}</td>
            </tr>
          `;
        }).join('');
      };
      
      const tableHeader = `
        <tr>
          <th>Rank</th>
          <th>ID</th>
          <th>True Quality</th>
          <th>Est. Score</th>
          <th>Error</th>
          <th># Ratings</th>
        </tr>
      `;
      
      document.getElementById('unweightedTable').innerHTML = tableHeader + makeTableRows(sortedByUnweighted, false);
      document.getElementById('weightedTable').innerHTML = tableHeader + makeTableRows(sortedByWeighted, true);
      
      // User reliability table
      const sortedUsers = [...users].sort((a, b) => b.reliability - a.reliability);
      
      const userRows = sortedUsers.map((user, idx) => {
        const numRatings = ratings.filter(r => r.userId === user.id).length;
        
        // Calculate average error
        let errorSum = 0;
        let errorCount = 0;
        ratings.forEach(r => {
          if (r.userId === user.id) {
            const item = content[r.contentId];
            errorSum += Math.abs(r.rating - item.trueQuality);
            errorCount++;
          }
        });
        const avgError = errorCount > 0 ? errorSum / errorCount : 0;
        
        const reliabilityClass = user.reliability > 1.2 ? 'highlight' : (user.reliability < 0.3 ? 'lowlight' : '');
        
        return `
          <tr>
            <td>${idx + 1}</td>
            <td>User ${user.id}</td>
            <td>${user.type}</td>
            <td class="${reliabilityClass}">${user.reliability.toFixed(3)}</td>
            <td>${avgError.toFixed(3)}</td>
            <td>${numRatings}</td>
          </tr>
        `;
      }).join('');
      
      document.getElementById('userTable').innerHTML = `
        <tr>
          <th>Rank</th>
          <th>ID</th>
          <th>Type</th>
          <th>Reliability</th>
          <th>Avg Error</th>
          <th># Ratings</th>
        </tr>
        ${userRows}
      `;
      
      // Reliability distribution
      const reliabilityBins = Array(20).fill(0);
      users.forEach(user => {
        const bin = Math.floor((user.reliability - params.rMin) / (params.rMax - params.rMin) * 19);
        const clampedBin = Math.max(0, Math.min(19, bin));
        reliabilityBins[clampedBin]++;
      });
      
      const reliabilityData = reliabilityBins.map((count, i) => ({
        value: count,
        color: '#3498db'
      }));
      
      drawBarChart(
        document.getElementById('reliabilityChart'),
        reliabilityData,
        {
          xLabel: 'Reliability Bin',
          yLabel: 'Count',
          maxValue: Math.max(...reliabilityBins)
        }
      );
      
      // Error scatter plot
      const scatterData = users.map(user => {
        let errorSum = 0;
        let errorCount = 0;
        ratings.forEach(r => {
          if (r.userId === user.id) {
            const item = content[r.contentId];
            errorSum += Math.abs(r.rating - item.trueQuality);
            errorCount++;
          }
        });
        const avgError = errorCount > 0 ? errorSum / errorCount : 0;
        
        const colors = {
          discerning: '#27ae60',
          average: '#3498db',
          contrarian: '#e74c3c',
          random: '#95a5a6',
          colluding: '#e67e22'
        };
        
        return {
          x: user.reliability,
          y: avgError,
          color: colors[user.type] || '#3498db'
        };
      });
      
      drawScatterPlot(
        document.getElementById('errorChart'),
        scatterData,
        {
          xLabel: 'User Reliability',
          yLabel: 'Average Rating Error',
          minX: 0,
          maxX: params.rMax,
          minY: 0,
          maxY: 1
        }
      );
      
      // Convergence chart
      const convergenceDatasets = [
        {
          label: 'Œî Content Score',
          data: history.deltaQ,
          color: '#3498db'
        },
        {
          label: 'Œî User Reliability',
          data: history.deltaR,
          color: '#e74c3c'
        }
      ];
      
      drawLineChart(
        document.getElementById('convergenceChart'),
        convergenceDatasets,
        {
          xLabel: 'Iteration',
          yLabel: 'Change',
          minValue: 0
        }
      );
    }
    
    // ==================== MAIN SIMULATION ====================
    function runSimulation() {
      initializeParams();
      
      console.log('Generating data...');
      generateUsers();
      generateContent();
      generateRatings();
      
      console.log('Running algorithm...');
      const history = runAlgorithm();
      
      console.log('Displaying results...');
      displayResults(history);
      
      console.log('Simulation complete!');
    }
    
    // Initialize on load
    updateDisplayedValues();
    runSimulation();
  </script>
</body>
</html>
